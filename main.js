// module to write to file and execute commands from cmd line
const fs = require('fs');
const { promisify } = require("util");
const exec = promisify(require("child_process").exec);

// extract data from metadata.json
let metadata = require('.\\src\\data\\metadata.json');
let config = require('.\\config.json');
let token = config["token"];
let standardLabels = metadata["standard"];
let extensionsLabels = metadata["extensions"];
let psExtensionsActiveLabels = metadata["ps_extensions_active"];
let psExtensionsRetiredLabels = metadata["ps_extensions_retired"];
let fixVersion = metadata["fixVersion"].replace(" ", "%20");
let cycleNameRelease = metadata["cycleNameRelease"].replace(" ", "%20");
let cycleNameAdhoc = metadata["cycleNameAdhoc"].replace(" ", "%20");

// initialize global variables
var labelToFailedTestsRelease = {}
var all_labels = standardLabels.concat(extensionsLabels).concat(psExtensionsActiveLabels).concat(psExtensionsRetiredLabels); //list of all labels -- order matters
for (const label of all_labels) labelToFailedTestsRelease[label] = [];
var count = all_labels.length; // keeping count to see all labels are covered before writing to files


/**
 * Return a Jira query as a url of all automated tests within given label
 * @param {string} label to generate query for
 */
function getJQLLink(label) {
    return "https://fake/jira/api/to/issues/with/labels/" + label + "and/status/auto/complete/within/project/release";
}

/**
 * Return a Zephyr query as a url of all tests under given label with cycle as cycleName and version as fixVersion
 * @param {*} label to generate query for
 * @param {*} cycleName for the query
 */
function getZQLLink(label, cycleName) {
    return "https://fake/zephyr/url/to/issues/with/labels/" + label + "and/cycle/name" + cycleName + "and/fix/version" + fixVersion + "'";
}

/**
 * Return total number of autoamted issues that have not been included in the version and cycle specified (purple bar) within a label
 * This function is stricly used for the Release Candidate cycle
 * @param {*} statuses a json mapping execution status to number of tests with that execution status within a label
 * @param {*} totalAutomated total number of automated test for a label
 * @returns 
 */
function getSumOfNoneCycledTests(statuses, totalAutomated) {
    var numCycledTests = statuses["FAIL"] + statuses["PASS"] + statuses["WIP"] + statuses["BLOCKED"] + statuses["CRC FAILURE"] + statuses["CONDITIONAL PASS"] + statuses["UNEXECUTED"];
    if (totalAutomated - numCycledTests >= 0) return totalAutomated - numCycledTests;
    return 0;
}

/**
 * Prettify json data and write to a json file under \data folder with filename
 * @param {*} filename filename to write json data to
 * @param {*} data json data generated by ParseAndStoreApiOutputs
 */
function saveToFile(filename, data) {
    var prettyData = JSON.stringify(data, null, 4);
    fs.writeFile('./src/data/' + filename, prettyData, function (err, result) {
        if (err) console.log('Error in saving to file', err);
    });
}

/**
 * Parses and stores Zephyr and Jira API call outputs within \data
 * @param {*} labelList list of labels within labelsType
 * @param {*} labelsType the label group - this can be standard, extensions, ps_extensions_active, or ps_extensions_retired
 */
let ParseAndStoreApiOutputs = async function ParseAndStoreApiOutputs(labelList, labelsType) {
    var jiraLabelToIssueIds = {}; //map label to automated issue ids within that label
    var zephyrLabelToIssueIdsRelease = {}; //map label to automated issue ids that are added to the Release Candidate cycle
    var zephyrLabelToIssueIdsAdhoc = {}; //map label to automated issue ids that are added to the Ad hoc cycle
    var labelToMissingIssuesInCycle = {} // map label to issues not included in the Release Candidate cycle 
    var labelToExecutionStatusesRelease = {} //map label to dictionary which maps execution status to number of tests with that status e.g. {"Database_Tools": {"FAIL": 0, "PASS": 10...}, ...} for the Release Candidate cycle
    var labelToExecutionStatusesAdhoc = {} // same as above but for Ad hoc cycle
    for (const label of labelList) {
        jiraLabelToIssueIds[label] = [];
        zephyrLabelToIssueIdsRelease[label] = [];
        zephyrLabelToIssueIdsAdhoc[label] = [];
        labelToMissingIssuesInCycle[label] = []; // to be completed at the very end
        labelToExecutionStatusesRelease[label] = { "FAIL": 0, "PASS": 0, "WIP": 0, "BLOCKED": 0, "CRC FAILURE": 0, "CONDITIONAL PASS": 0, "UNEXECUTED": 0, "NOT IN CYCLE": 0 };
        labelToExecutionStatusesAdhoc[label] = { "FAIL": 0, "PASS": 0, "WIP": 0, "BLOCKED": 0, "CRC FAILURE": 0, "CONDITIONAL PASS": 0, "UNEXECUTED": 0 };
    }

    // Jira API - storing automated issues within each label 
    for (const label of labelList) {
        let issuesByLabelUrl = getJQLLink(label);
        var out = await exec(
            'curl -k -H "Authorization: Bearer ' + token + '" GET -H "Content-Type: application/json" "' +
            issuesByLabelUrl + '"', { maxBuffer: 5 * 1024 * 1024 * 1024, }
        );
        var jsonOut = JSON.parse(out.stdout);
        for (const issue of jsonOut["issues"]) {
            if (!jiraLabelToIssueIds[label].includes(issue["id"]))
                jiraLabelToIssueIds[label].push(issue["id"]);
        }
        console.log('Fetched automated issues for ' + label);
    }
    var fileName = labelsType + "_label_to_automated_issue_ids.json";
    saveToFile(fileName, jiraLabelToIssueIds);

    // Zephyr API - storing test execution statuses 
    for (let label of labelList) {
        count = count - 1;
        let executionStatusUrlRelease = getZQLLink(label, cycleNameRelease);
        let executionStatusUrlAdhoc = getZQLLink(label, cycleNameAdhoc);
        var outRelease = await exec('curl -k -H "Authorization: Bearer ' + token + '" GET -H "Content-Type: application/json" "' + executionStatusUrlRelease + '"', { maxBuffer: 5 * 1024 * 1024 * 1024, });
        var outAdhoc = await exec('curl -k -H "Authorization: Bearer ' + token + '" GET -H "Content-Type: application/json" "' + executionStatusUrlAdhoc + '"', { maxBuffer: 5 * 1024 * 1024 * 1024, });
        var jsonOutRelease = JSON.parse(outRelease.stdout);
        var jsonOutAdhoc = JSON.parse(outAdhoc.stdout);

        // Release Candidate cycle - loop through exeuction statuses 
        for (const execution of jsonOutRelease["executions"]) {
            // store issue ids under execution 
            if (!zephyrLabelToIssueIdsRelease[label].includes(execution["issueId"]))
                zephyrLabelToIssueIdsRelease[label].push(execution["issueId"]);
            // add execution status
            var execStatus = execution["status"]["name"];
            labelToExecutionStatusesRelease[label][execStatus] += 1;
            // add all failed and crc failed tests - Non Ad hoc Fails or CRC Fails button
            if (execStatus == "FAIL" || execStatus == "CRC FAILURE") 
                if (!labelToFailedTestsRelease[label].includes(execution["issueId"]))
                    labelToFailedTestsRelease[label].push(execution["issueId"]);
        }
        console.log('Fetched ' + cycleNameRelease.replace("%20", " ") + ' execution statuses for ' + label);

        // Ad hoc cycle - loop through exeuction statuses 
        for (const execution of jsonOutAdhoc["executions"]) {
            if (!zephyrLabelToIssueIdsAdhoc[label].includes(execution["issueId"]))
                zephyrLabelToIssueIdsAdhoc[label].push(execution["issueId"]);
            // add execution status
            var execStatus = execution["status"]["name"];
            labelToExecutionStatusesAdhoc[label][execStatus] += 1;
        }
        console.log('Fetched ' + cycleNameAdhoc.replace("%20", " ") + ' execution statuses for ' + label);
        labelToExecutionStatusesRelease[label]["NOT IN CYCLE"] = getSumOfNoneCycledTests(labelToExecutionStatusesRelease[label], jiraLabelToIssueIds[label].length); // Release candidate cycle only has NOT IN CYCLE
    }

    saveToFile(labelsType + "_label_to_execution_statuses.json", labelToExecutionStatusesRelease);
    saveToFile(labelsType + "_label_to_execution_statuses_adhoc.json", labelToExecutionStatusesAdhoc);
    saveToFile(labelsType + "_label_to_cycled_issue_ids.json", zephyrLabelToIssueIdsRelease);
    saveToFile(labelsType + "_label_to_cycled_issue_ids_adhoc.json", zephyrLabelToIssueIdsAdhoc);
    // make sure all the labels have been covered before storing this file
    if (count == 0) saveToFile('label_to_failed_tests_release.json', labelToFailedTestsRelease);
};

ParseAndStoreApiOutputs(standardLabels, "standard");
ParseAndStoreApiOutputs(extensionsLabels, "extensions");
ParseAndStoreApiOutputs(psExtensionsActiveLabels, "ps_extensions_active");
ParseAndStoreApiOutputs(psExtensionsRetiredLabels, "ps_extensions_retired");
